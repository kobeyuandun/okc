// Top-level build file where you can add configuration options common to all sub-projects/modules.

import org.codehaus.groovy.runtime.StackTraceUtils

int[] sdksAvailable() {
    def sdks = new ByteArrayOutputStream()
    def androidSdkDir = androidSDKDir()
    if (System.getProperty('os.name').contains("Mac")) {
        exec {
            workingDir androidSdkDir + "/tools"
            commandLine './android', 'list'
            standardOutput = sdks
        }
    } else {
	def str = androidSdkDir + File.separator+"tools"
	def str1 = str.substring(0,2)
	def str2 = str.substring(2)
        exec {
   //     workingDir androidSdkDir + File.separator+"tools"

			commandLine  str1
			commandLine 'cd' ,str2
			commandLine 'android.bat', 'list'
        standardOutput = sdks
        }
    }


    sdks = sdks
            .toString()
            .split('\n')
            .findAll { it ==~ /\s*API level:\s*(\d+).*/ }
            .collect { (it =~ /\s*API level:\s*(\d+).*/)[0][1].toInteger() }
            .sort({ a, b -> b <=> a })
			
    sdks


}

int highestSdkAvailable(int defaultSdk) {
    try {
        def sdks = sdksAvailable()
        def highestSdk = sdks[2]
        if (highestSdk != null) {
            println "Using highest found SDK " + highestSdk
            highestSdk
        } else {
            println "No installed SDKs found. Using default SDK " + defaultSdk
            defaultSdk
        }
    } catch (any) {
        println "Exception while determining highest SDK. Using default SDK " +
                defaultSdk
        StackTraceUtils.sanitize(any).printStackTrace()
        defaultSdk
    }
}
/*我们团队内部建立的编译环境初始化函数
  这个函数的目的是
  1  解析一个名为local.properties的文件，读取AndroidSDK和NDK的路径
  2  获取最终产出物目录的路径。这样，编译完的apk或者jar包将拷贝到这个最终产出物目录中
  3 获取Android SDK指定编译的版本
*/

def initMinshengGradleEnvironment() {
    println "initialize Minsheng Gradle Environment ....."
    Properties properties = new Properties()
    //local.properites也放在posdevice目录下
//    FilepropertyFile  = new File(rootDir.getAbsolutePath()+ "/local.properties")
//    properties.load(propertyFile.newDataInputStream())
    /*
      根据Project、Gradle生命周期的介绍，settings对象的创建位于具体Project创建之前
      而Gradle底对象已经创建好了。所以，我们把local.properties的信息读出来后，通过
     extra属性的方式设置到gradle对象中
      而具体Project在执行的时候，就可以直接从gradle对象中得到这些属性了！
    */
    gradle.ext.api = properties.getProperty('sdk.api')
    gradle.ext.sdkDir = properties.getProperty('sdk.dir')
    gradle.ext.ndkDir = properties.getProperty('ndk.dir')
    gradle.ext.localDir = properties.getProperty('local.dir')
    //指定debugkeystore文件的位置，debug版apk签名的时候会用到
    gradle.ext.debugKeystore = properties.getProperty('debug.keystore')
    println "initialize Minsheng Gradle Environment completes..." + gradle.ext.sdkDir
}

String androidSDKDir() {
//    initMinshengGradleEnvironment()
    def androidExecPath = new ByteArrayOutputStream()
    def sdkDirProp
    def rootDir = project.rootDir
    def localProperties = new File(rootDir, "/local.properties")
    if (localProperties.exists()) {
        Properties properties = new Properties()
        localProperties.withInputStream { instr ->
            properties.load(instr)
        }

        sdkDirProp = properties.getProperty('sdk.dir')
        
        return sdkDirProp
    } /*else if (sdkDirProp != null || sdkDirProp != "") {
        if (System.getProperty('os.name').contains("Mac")) {
            try {
                exec {
                    commandLine 'which', 'android'
                    standardOutput = androidExecPath
                }
                println "find android exec path: " + androidExecPath.toString()
                return (androidExecPath.toString().trim()).getParentFile().getParentFile()
            } catch (ExecException) {
                exec {
                    commandLine 'grep', 'sdk.dir', 'local.properties'
                    standardOutput = androidExecPath
                }
                println "find android sdk with local.properties: " + androidExecPath.toString()
                return androidExecPath.toString().trim().split('=')[1]
            }
        } else {
            exec {
                commandLine 'set', 'ANDROID_HOME'
                standardOutput = androidExecPath
            }
            return (androidExecPath.toString().trim().split('=')[1])
        }

    }*/ else {
        return "f:\\android-sdk_r14-windows\\android-sdk-windows"

    }

}

String[] buildToolsAvailable() {
    println "sdk dir: " + androidSDKDir()
    def buildToolsDir = new File(androidSDKDir(), "build-tools")
    buildToolsDir.list([accept: { d, f -> !f.contains("android") }] as FilenameFilter).sort { a, b -> b <=> a }
}

String latestBuildToolsAvailable(String defaultBuildTools) {
    try {
        def buildToolsVersions = buildToolsAvailable()
        def latestBuildTools = buildToolsVersions[0]
        buildToolsVersions.each { dir ->
            if (new File(dir).isDirectory()) {
                latestBuildTools = dir;
                println "$dir"
            }
        }
        if (latestBuildTools != null) {
            println "Using latest found build tools " + latestBuildTools
            latestBuildTools
        } else {
            println "No installed build tools found. Using default build tools " +
                    defaultBuildTools
            defaultBuildTools
        }
    } catch (any) {
        println "Exception while determining latest build tools. Using default build tools " +
                defaultBuildTools
        StackTraceUtils.sanitize(any).printStackTrace()
        defaultBuildTools
    }
}

ext.compileSdkVersion = highestSdkAvailable(22)
ext.buildToolsVersion = latestBuildToolsAvailable("23")

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:1.5.0'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
